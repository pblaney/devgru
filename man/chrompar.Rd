% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/swissArmyKnife.R
\name{chrompar}
\alias{chrompar}
\title{Scaffold function around \code{easypar} to run workflows in parallel by chromosome}
\usage{
chrompar(
  par_function,
  par_chromosomes,
  ...,
  run_in_par = T,
  par_cpus = NULL,
  par_packages = NULL
)
}
\arguments{
\item{par_function}{The function that will be executed in parallel by chromosome, written
as the function name without the \verb{()} a the end}

\item{par_chromosomes}{The set of chromosomes to execute in parallel, non-duplicated values
and can be any chromosomes as long as present in input data}

\item{...}{The input parameters that will be passed to \code{par_function} for execution, these
must be provided in the order expected by \code{par_function}}

\item{run_in_par}{Run the jobs in parallel and not sequentially, default: TRUE}

\item{par_cpus}{Number of CPUs to use for parallel execution, \code{easypar} will safeguard against using
all available CPUs}

\item{par_packages}{Vector of character strings designating special packages needed for
executing the \code{par_function}}
}
\value{
GenomicRanges object with properly sorted genomic coordinates
}
\description{
A scaffold function to be used within other complex workflow functions that provides
easy API to \code{easypar} functionality and executes a function in parallel by chromosome

The scaffold takes a function where the input can be subset by chromosome and the
expected output is either a data.table or GenomicRanges object
}
\examples{
# Run as part of the `get_dryclean_segmentation()` workflow using
# `get_cbs_per_chromosome()` as the par_function
# final_cbs_segmentation <- chrompar(
# par_function = get_cbs_per_chromosome,
# par_chromosomes = chrom_iter_list,
# par_cpus = threads,
# seqnames_nona, foreground_cov_nona, start_nona, sample_id)

}
\keyword{core}
